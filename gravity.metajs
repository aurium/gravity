"use strict";

try {

var log = function() { // debug
  var args = []; // debug
  for (var i=0; i<arguments.length; i++) args.push(arguments[i]); // debug
  /Android/.test(navigator.userAgent) ? // debug
    0: //alert(args.join(' - ')) : // debug
    console.log.apply(console,args); // debug
}; // debug

var biteLimit = function(val) {
  return val>255 ? 255 : ( val<0 ? 0 : val );
}

var rand = function(num) { return (Math.random()-0.5) * (num||1) };

var makeAudio = function(length, toneIni, toneEnd, noise, gainFn) {
  gainFn = {
    line: function(i,length){ return 1-i/length },
    triangle: function(i,length){
      return (i<length/3) ? i/(length/3) : 1-(i-(length/3))/(length*2/3)
    }
  }[gainFn||'line'];
  var toneDelta = toneEnd - toneIni;
  var data = [];
  for ( var i=0; i<length; i++ )
    data.push(biteLimit(
      Math.sin( i*(toneIni+toneDelta*(i/length))/800 + noise*rand(pi) )
      * 127 // half value
      * gainFn(i,length) // increase/decrease amplitude
      + 127 // move to medium line
    ));
  var wav = new RIFFWAVE(data);
  var player = document.createElement('audio');
  player.src = wav.dataURI;
  return player;
}
var explosionSound = makeAudio(10000, 150, 50, 1);
var gunSound = makeAudio(4000, 1500, 600, 0.2, 'triangle');

var randColor = function(mr,vr,mg,vg,mb,vb) {
  var r1 = Math.round( mr + rand(vr) ),
      g1 = Math.round( mg + rand(vg) ),
      b1 = Math.round( mb + rand(vb) ),
      r2 = Math.round( r1*2.8 ),
      g2 = Math.round( g1*2.8 ),
      b2 = Math.round( b1*2.8 ),
      r3 = Math.round( r1*3.6 ),
      g3 = Math.round( g1*3.6 ),
      b3 = Math.round( b1*3.6 );
      biteLimit(r2);
      biteLimit(g2);
      biteLimit(b2);
      biteLimit(r3);
      biteLimit(g3);
      biteLimit(b3);
  return [ [r1,g1,b1].join(','), [r2,g2,b2].join(','), [r3,g3,b3].join(',') ];
};

var distP2P = function(p1, p2) {
  var dx = p1.x - p2.x,
      dy = p1.y - p2.y,
      d = Math.sqrt( dx*dx + dy*dy ),
      x = dx / d,
      y = dy / d;
  return { x:x, y:y, d:d }
};

var ctx = c.getContext('2d'),
    ctxMap = map.getContext('2d'),
    d = document,
    b = d.body,
    touchable = false,
    abs = Math.abs,
    pi = Math.PI,
    completeRad = 2 * pi, // complete revolution
    deg90 = pi/2,
    turn3 = completeRad/3,
    //macro orbDist1: 500
    //macro orbDist2: 900
    //macro orbDist3: 1400
    //macro orbDist4: 1900
    //macro orbVel1: .0020
    //macro orbVel2: .0010
    //macro orbVel3: .0005
    //macro orbVel4: .0002
    planets = {
      sun:{ m:200, c:['255,180,0','255,255,10','255,255,80'], r:150+rand(10) },

      // Orbit 1
      p1a:  { m:40, c:randColor(100,60,80,80,0,120),
              r:35+rand(10), d:orbDist1+rand(20), v:orbVel1,  a:rand() },

      p1b:  { m:40, c:randColor(100,60,80,80,0,120),
              r:35+rand(10), d:orbDist1+rand(20), v:orbVel1,  a:2+rand() },

      p1c:  { m:40, c:randColor(100,60,80,80,0,120),
              r:35+rand(10), d:orbDist1+rand(20), v:orbVel1,  a:4+rand() },

      // Orbit 2
      p2a:  { m:30, c:['0,100,180','0,180,220','50,220,255'],
              r:40, d:orbDist2+rand(50), v:orbVel2, a:0.0+rand()*.8 },
      m2a1: { m:20, c:['100,100,100','200,200,200','250,250,250'],
              r:25,  d:130+rand(10),  v:orbVel1*4,  a:rand(7), p:'p2a' },

      p2b:  { m:30, c:randColor(100,60,80,80,0,120),
              r:35+rand(10), d:orbDist2+rand(50), v:orbVel2, a:1.5+rand()*.8 },

      p2c:  { m:30, c:randColor(100,60,80,80,0,120),
              r:45+rand(10), d:orbDist2+rand(50), v:orbVel2, a:3.0+rand()*.8 },

      p2d:  { m:30, c:randColor(100,60,80,80,0,120),
              r:35+rand(10), d:orbDist2+rand(50), v:orbVel2, a:4.5+rand()*.8 },

      // Orbit 3
      p3a:  { m:50, c:randColor(100,60,80,80,0,120),
              r:70+rand(15), d:orbDist3+rand(20), v:orbVel3, a:2+rand() },

      p3b:  { m:50, c:randColor(100,60,80,80,0,120),
              r:80+rand(15), d:orbDist3+rand(20), v:orbVel3, a:4+rand() },
      m3b1: { m:20, c:randColor(100,60,80,80,0,120),
              r:20+rand(2),  d:160+rand(10),   v:orbVel3*6,  a:rand(7), p:'p3b' },
      m3b2: { m:20, c:randColor(100,60,80,80,0,120),
              r:18+rand(3),  d:230+rand(10),  v:orbVel3*3,  a:rand(), p:'p3b' },
      m3b3: { m:20, c:randColor(100,60,80,80,0,120),
              r:18+rand(3),  d:230+rand(10),  v:orbVel3*3,  a:3+rand(), p:'p3b' },

      p3c:  { m:50, c:randColor(100,60,80,80,0,120),
              r:70+rand(15), d:orbDist3+rand(20), v:orbVel3, a:0+rand() },

      // Orbit 4
      p4a:  { m:50, c:randColor(100,60,80,80,0,120),
              r:50+rand(20), d:orbDist4+rand(50), v:orbVel4, a:0.0+rand()*.8 },

      p4b:  { m:50, c:randColor(100,60,80,80,0,120),
              r:50+rand(20), d:orbDist4+rand(50), v:orbVel4, a:1.5+rand()*.8 },

      p4c:  { m:50, c:randColor(100,60,80,80,0,120),
              r:50+rand(20), d:orbDist4+rand(50), v:orbVel4, a:3.0+rand()*.8 },

      p4d:  { m:50, c:randColor(100,60,80,80,0,120),
              r:50+rand(20), d:orbDist4+rand(50), v:orbVel4, a:4.5+rand()*.8 }
    },
    biggerPlanetD = orbDist4,
    boids = [], // see "Initialize Boids"
    sun = planets.sun,
    // zoom: the wanted zoom.
    // z: the current zoom.
    // scrC*: the center of the screen, calculated on start and each resize.
    // viewC*: the related wanted position to put on the center of the screen.
    // vC*: the current related position to put on the center of the screen.
    vCX = null,
    vCY = null,
    viewCX = 0,
    viewCY = 0,
    scrCX = 0,
    scrCY = 0,
    w = 0,
    h = 0,
    z = 0.1,
    zoom = 1,
    ship = null, // see "Initialize Ship"
    shipAlive = false,
    usrInput = {},
    explosions = [],
    focus = ship,
    imgDataObj, imgData, imgDataLength,
    gConst = 0.01, //6.674e-11
    now = Date.now,
    start = now(),
    pixelRatio = window.devicePixelRatio;


viewport.setAttribute('content',
  'width=device-width, user-scalable=no, initial-scale=' + (1/pixelRatio)
);
if ( pixelRatio >= 2 ) b.className += ' pix20';
else if ( pixelRatio > 1 ) b.className += ' pix15';

try {
  if (document.createEvent("TouchEvent")) {
    b.className += ' touchable';
    touchable = true;
  }
} catch(e) { }

var shipDie = function(txt, showNow) {
  explosionSound.play();
  shipAlive = false;
  if (!showNow) return setTimeout( function(){ shipDie(txt,true) }, 500 );
  focus = sun;
  zoom = (h/biggerPlanetD)/2;
  if (!txt) txt = 'You die.'
  deadMsg.innerHTML += txt +
    '<a class="bt" href="javascript:document.location.reload()">Restart</a>';
  deadMsg.style.display = 'block';
};

(window.onresize = function(e) {
  if (vCX==null) {
    vCX = planets.p2a.d/2;
    vCY = planets.p2a.d/2;
  }
  scrCX = (c.width = w = d.documentElement.clientWidth) / 2;
  scrCY = (c.height = h = d.documentElement.clientHeight) / 2;
  map.cx = (map.width = mapBox.clientWidth - 10) / 2;
  map.cy = (map.height = mapBox.clientHeight - 10) / 2;
  ctxMap.fillStyle = '#333';
  ctxMap.fillRect (0,0,map.width,map.height);
  log(w,h, map.width,map.height);
  /*
  log( 'resize', scrCX,w, scrCY,h ); // debug
  imgDataObj = ctx.getImageData(0,0,w,h);
  imgData = imgDataObj.data;
  for (var x=-scrCX; x<scrCX; x++) {
    for (var y=-scrCY; y<scrCY; y++) {
      var i = w*(y+scrCY) + x+scrCX,
          j = y * x + start,
          v1 = (x*x/3+y*y-3e4) / 20,
          v2 = abs(j) % v1;
      if ( v2 < 15 ) {
        imgData[i*4+0] = 155 + ( v2%3<0.5 ? 80 : 0 )
        imgData[i*4+1] = 155 + ( v2%4<0.5 ? 90 : 0 )
        imgData[i*4+2] = 160 + ( v2%2<0.5 ? 90 : 0 )
        imgData[i*4+3] = v2<5 ? v2*70 : v2*17
        //imgData[i*4+3] = (1-(abs(j)%(x*x+y*y-1e4)/400)) * 255;
      }
    }
  }*/
})();

var boidsOnPlanet = function(p) {
  var list = [];
  boids.forEach(function(b){ if(b.planet==p) list.push(b) });
  return list;
};

var ownerOfPlanet = function(p) {
  var boids = boidsOnPlanet(p);
  if (boids.length==0) return -1;
  var owner = boids[0].o;
  boids.forEach(function(b){ owner = (owner+b.o)/2 });
  return owner;
};

Array.prototype.remove = function(item) {
  var newList = [];
  this.forEach(function(i){
    if(i!=item) newList.push(i);
  });
  return newList;
};

var landingPos = function(obj, p) {
  return {
    x: p.x + Math.cos(obj.rotate)*(p.r+obj.r),
    y: p.y + Math.sin(obj.rotate)*(p.r+obj.r)
  }
};

var updatePosition = function(obj, inPlanet, planetProximation) {
  var p = obj.planet;
  if (p) { // in a planet
    obj.vx = obj.vy = 0;
    obj.rotateV = (obj.rotateV||0) * 0.99;
    obj.rotate = (obj.rotate||0) + obj.rotateV;
    obj.x = p.x + Math.cos(obj.rotate||0)*(p.r+obj.r);
    obj.y = p.y + Math.sin(obj.rotate||0)*(p.r+obj.r);
    inPlanet(p);
  }
  else { // Object is fling
    for ( var id in planets ) {
      var p = planets[id];
      var dist = distP2P( p, obj );
      // Normal gravity lower to distance. Here never is so far.
      var f = dist.d<999 ? (gConst*p.m)/dist.d : (gConst*p.m)/999;
      obj.vx = (obj.vx||0) + f * dist.x;
      obj.vy = (obj.vy||0) + f * dist.y;
      var proximity = dist.d - p.r - obj.r;
      for ( var limitDist in planetProximation ) {
        // Near to the planet
        if (proximity <= limitDist) planetProximation[limitDist](p, proximity);
      }
    }
  }
  obj.rotate  %= completeRad;
  if (obj.rotate<0) obj.rotate += completeRad;
  obj.x += obj.vx;
  obj.y += obj.vy;
};

var getAngleToPlanet = function(obj, planet) {
  var dist = distP2P(obj, planet);
  var acos = Math.acos(dist.x);
  var asin = Math.asin(dist.y);
  var angleToPlanet = (asin > 0 ? acos : completeRad - acos);
  return angleToPlanet % completeRad;
};

var shipLastExitTripulation=0, shipLastJet=0;
var releaseTripulation = function() {
  var b = ship.tripulation[0];
  // Has boid AND 1sec no user up AND 1sec last boid leave the ship
  if ( b && (now()-shipLastJet)>1000 && (now()-shipLastExitTripulation)>1000 ) {
    shipLastExitTripulation = now();
    b.planet = ship.planet;
    b.r = 2;
    b.rotate = ship.rotate + rand(.5);
    boids.push(b);
    ship.tripulation = ship.tripulation.remove(b);
  }
};

var ticCounter = 0, framesPerSec = 30;

setInterval(function() {
  ticCounter++;
  var p, dist;

  if ( shipAlive ) {
    var absShipV = abs(ship.vx) + abs(ship.vx);
    if ( absShipV > 1 ) zoom = 2/absShipV;
    else zoom = 2;
    if ( zoom < 0.5 ) zoom = 0.5;
  }
  //focus = sun; zoom = (h/biggerPlanetD)/2.1; // debug

  // Update planets positions:
  for ( var id in planets ) {
    p = planets[id];
    if (!p.d) {
      p.x = p.y = 0;
    } else {
      p.a += p.v;
      var oldx = p.x, oldy = p.y;
      p.x = Math.cos(p.a)*p.d + planets[p.p||'sun'].x;
      p.y = Math.sin(p.a)*p.d + planets[p.p||'sun'].y;
      p.vx = p.x - oldx;
      p.vy = p.y - oldy;
      //log( '1>', id, p.a, p.v, p.d, p.x )
    }
  }

  p = planets;

  /*** Initializations ********************************************************/
  if ( boids.length == 0 ) {
    log('Initialize Boids'); //debug
    for (var i=0; i<8; i++)
      boids.push({
        o:0, planet:p.p2a, r:1+rand(), rotate:rand(completeRad), rotateV:rand(.01)
      });
    boids.push({ o:1, planet:p.p3a, r:2, rotateV:rand(.01) });
    boids.push({ o:1, planet:p.p3b, r:2, rotateV:rand(.01) });
    boids.push({ o:1, planet:p.p3c, r:2, rotateV:rand(.01) });
  }
  if ( ticCounter%(10*framesPerSec) == 0 ) {
    // Invasion from outer space each 10 secs
    boids.push({ // the ship will never see it born
      o: 1, r: 2,
      x: (ship.x>0 ? -1.2 : 1.2) * biggerPlanetD,
      y: rand(4000),
      vy: rand(10)
    });
  }

  if ( !ship ) {
    log('Initialize Ship'); //debug
    shipAlive = true;
    ship = {
      tripulation: [{o:0, r:1, color:randColor(0,40, 90,50, 0,50)}],
      planet: p.p2a,
      rotate: -pi/2,
      r: 10
    };
    focus = ship;
  }

  /*** Updates ****************************************************************/
  // Update ship position:
  if (shipAlive) {
    updatePosition(ship,
      function(p) {
        ship.rotateV = 0;
        if (boidsOnPlanet(p).length < 4) releaseTripulation();
      },
      {
        15: function(p, proximity) { // Near to the planet
          // Auto pilot try to help to align the ship for landing
          var angleToPlanet = getAngleToPlanet(ship, p);
          // Remove near to zero jump (useless complete turn the ship)
          if ( angleToPlanet < pi/2 && ship.rotate > pi*1.5 ) ship.rotate -= completeRad;
          if ( angleToPlanet > pi*1.5 && ship.rotate < pi/2 ) ship.rotate += completeRad;
          // Adjust ship rotation
          if ( angleToPlanet-ship.rotate > 0.2 ) ship.rotate += 0.1;
          else if ( angleToPlanet-ship.rotate > 0.1 ) ship.rotate += 0.03;
          if ( angleToPlanet-ship.rotate < -0.2 ) ship.rotate -= 0.1;
          else if ( angleToPlanet-ship.rotate < -0.1 ) ship.rotate -= 0.03;
        },
        0: function(p, proximity) { // Touch the planet
          if (p == sun) { // Ship die if dropped into sun
            shipDie('You crash in the sun before colonize all start system.');
            explosions.push({ x:ship.x, y:ship.y, r:10 });
          } else { // Ship landed a planet
            if (proximity < -2) { // Too hard! Explode
              shipDie(
                'You crash in a planet before colonize all start system.'+
                '<p/><strong>Impact: '+
                 Math.round(proximity*-100)+'uF.</strong> Maximum is 200uF.'
              );
              explosions.push({ x:ship.x, y:ship.y, r:10 });
            } else {
              if ( distP2P(ship, landingPos(ship, p)).d > 10 ) {
                log( 'CRASH',
                     'ship', ship.x, ship.y,
                     'expected', landingPos(ship, p) );
                shipDie(
                  'You crash in a planet before colonize all start system.'+
                  '<p/><strong>Bad angle.</strong>'
                );
                explosions.push({ x:ship.x, y:ship.y, r:10 });
              } else {
                ship.planet = p;
                releaseTripulation();
              }
            }
          }
        }
      }
    );
    if (usrInput.btU) {
      if (ship.planet) {
        ship.vx = Math.cos(ship.rotate) * 0.2 + ship.planet.vx;
        ship.vy = Math.sin(ship.rotate) * 0.2 + ship.planet.vy;
        ship.planet = false;
      } else {
        ship.vx += Math.cos(ship.rotate) * 0.1;
        ship.vy += Math.sin(ship.rotate) * 0.1;
      }
    }
    if ( usrInput.btL ) ship.rotateJet = -0.01;
    else if ( usrInput.btR ) ship.rotateJet = 0.01;
    else ship.rotateJet = 0;
    ship.rotateV += ship.rotateJet; // Side jets increase angular velocity
    ship.rotate  += ship.rotateV;   // Rotation state increased by angular velocity
    ship.rotateV *= 0.99;           // Rotation friction (Yeah... this is a fake space)
  }

  // Update boids positions:
  boids.forEach(function(b){
    updatePosition(b,
      function(p) { // in a planet callback
        if ( ship.planet == p ) {
          // The player ship is in this boid's planet!
          if (boidsOnPlanet(p).length < 4) {
            // Too few boids...
            if ( abs(ship.rotate-b.rotation) < pi/2 ) {
              // Near to the ship? Run away.
              b.rotateV += b.rotate<ship.rotate ? -1e-3 : 1e-3;
            }
          } else {
            // Too many boids. Get the ship!
            b.rotateV += b.rotate<ship.rotate ? 1e-4 : -1e-4;
          }
          if (
               abs(ship.rotate-b.rotate) < .01 &&  // boid is above the ship
               b.o == 0 &&                         // is one of the player's boid
               ship.tripulation.length < 3         // there is room for it
             ) {
            log('Go!', ship.tripulation);
            ship.tripulation.push(b);
            boids = boids.remove(b);
          }
        } else {
          // No ship here... boring life...
          // Never stops to walk the surface
          if ( (b.rotateV||0) == 0 ) b.rotateV = .01;
          if ( abs(b.rotateV) < .002 ) {
            // Prevent boids to walk all together, and never touch:
            if( rand()<-0.49 ) b.rotateV *= -1; // 1% chance to change direction
            b.rotateV*=1.5;
          }
        }
        // grow boid
        if ( b.r <= 3 ) { // not so big AND in a planet surface
          b.r += 0.01;
        }
        else if ( b.r > 3 &&                           // Big enough
                  boidsOnPlanet(p).length < p.r/6 &&   // not too many
                  rand(4) < -1                         // 25% chance to go
                ) {
          // Boid reproduction
          b.r = 1.5;
          boids.push({
            o: b.o, r: 1+rand(.5), planet: p, rotate: b.rotate+rand(.001)
          });
        }
      },
      {
        0: function(p, proximity) { // Touch the planet
          if (p == sun) { // Boid die if dropped into sun
            boids = boids.remove(b);
            explosions.push({ x:b.x, y:b.y, r:2, inc:.2 });
          } else { // Boid landed a planet
            b.planet = p;
            b.rotate = getAngleToPlanet(b, p);
          }
        }
      }
    );

    // test boid to boid collision
    boids.forEach(function(b2){
      if ( b2 != b ) {
        dist = distP2P(b2,b);
        if ( (dist.d - b.r - b2.r) < 0 ) {
          if (b.o != b2.o) { // Boids conflict. Both die.
            boids = boids.remove(b);
            boids = boids.remove(b2);
            explosions.push({ x:b.x, y:b.y, r:2, inc:.2 });
            explosions.push({ x:b2.x, y:b2.y, r:2, inc:.2 });
          } else { // Friend touch
            if (b.planet) { // in a planet
              var inc = b.r/5000 * ( b.rotate<b2.rotate ? 1 : -1 );
              b.rotateV  -= inc;
              b2.rotateV += inc;
            } else { // in the space
              b.vx += (1-dist.x)/100;
              b.vy += (1-dist.y)/100;
              b2.vx -= (1-dist.x)/100;
              b2.vy -= (1-dist.y)/100;
            }
          }
        }
      }
    });

  });

  // Adjust camera:
  var newZ = ( zoom + z*9 ) / 10;
  //macro sign: ( @1<0 ? -1 : 1 )
  if ( shipAlive && abs(newZ-z)>0.005 ) z += 0.005 * sign(newZ-z);
  else z = newZ;
  viewCX = scrCX - focus.x * z;
  viewCY = scrCY - focus.y * z;
  if ( z < 1 ) {
    vCX = ( viewCX + vCX*10 ) / 11;
    vCY = ( viewCY + vCY*10 ) / 11;
  } else {
    vCX = ( viewCX + vCX*5 ) / 6;
    vCY = ( viewCY + vCY*5 ) / 6;
  }

  var mapZ = (map.height/biggerPlanetD)/2.2;

  /******** Draw elements *****************************************************/
  // Clear all
  ctx.clearRect(0,0,w,h);
  ctxMap.clearRect(0,0,map.width,map.height);
  //ctxMap.fillStyle = 'rgba(0,0,0,0.02)';
  //ctxMap.fillRect (0,0,map.width,map.height);
  // Stars
  //ctx.putImageData(imgDataObj, 0, 0);
  // Sun rays
  // createRadialGradient's first ray must to be 0 for android.
  var sunRayZoom = z>.5 ? .45 + z/10 : z;
  //macro sunRayLength: sunRayZoom*sun.r*3
  var grd = ctx.createRadialGradient(vCX, vCY, 0, vCX, vCY, sunRayLength);
  grd.addColorStop(0, 'rgb('+sun.c[0]+')');
  grd.addColorStop(0.2, 'rgba('+sun.c[0]+',0.5');
  grd.addColorStop(1, 'rgba(0,0,0,0.5)');
  ctx.fillStyle = grd;
  //ctx.fillStyle = '#F80';
  ctx.beginPath();
  var timeDif = (now() - start)/16000;
  for (var i=timeDif; i<timeDif+7; i+=0.314*2) {
    ctx.arc( vCX, vCY, sunRayLength, i,i+0.314 );
    ctx.lineTo(vCX, vCY);
  }
  ctx.closePath();
  ctx.fill();
  // Draw Planets
  for ( id in planets ) {
    p = planets[id];
    // Planet Bright
    var grd = ctx.createRadialGradient(z*p.x+vCX, z*p.y+vCY, 0,
                                       z*p.x+vCX, z*p.y+vCY, z*p.r*2);
    grd.addColorStop(0, 'rgb('+p.c[1]+')');
    grd.addColorStop(0.48, 'rgb('+p.c[1]+')');
    grd.addColorStop(0.48, 'rgba('+p.c[2]+','+(p==sun?0.6:0.3*(z>.5?z:.5))+')');
    grd.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc( z*p.x+vCX, z*p.y+vCY, z*p.r*(p==sun?3:2), 0,7 );
    ctx.closePath();
    ctx.fill();
    // Planet Volume Shadow
    var grd = ctx.createRadialGradient(z*p.x+vCX, z*p.y+vCY, 0, //z*p.r/9,
                                       z*p.x+vCX, z*p.y+vCY, z*p.r);
    grd.addColorStop(0, 'rgba('+p.c[1]+',0)');
    grd.addColorStop(1, 'rgb('+p.c[0]+')');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc( z*p.x+vCX, z*p.y+vCY, z*p.r, 0,7 );
    ctx.closePath();
    ctx.fill();
    // Planet on the map
    var owner = ownerOfPlanet(p);
    var ownerColor;
    if (owner == -1)     ownerColor = 'rgb(220,220,220)';
    else if (owner == 0) ownerColor = 'rgb(50,240,50)';
    else if (owner == 1) ownerColor = 'rgb(240,100,50)';
    else ownerColor = 'rgb(255,0,255)';
    ctxMap.fillStyle = p==sun? '#FF7' : ownerColor;
    ctxMap.beginPath();
    ctxMap.arc( mapZ*p.x+map.cx, mapZ*p.y+map.cy, mapZ*p.r, 0,7 ); //(p==sun?3:0.6)
    ctxMap.closePath();
    ctxMap.fill();
  }
  // Draw Boids
  //boids.forEach(function(b){
  var totB = boids.length;
  for ( var i=0; i<totB; i++ ) {
    var b = boids[i];
    if ( !b.color ) {
      var c1 = 40, c2 = -40;
      if (rand()<0) c1*=-1, c2*=-1;
      b.color = (b.o == 0) ?
        randColor(c1/2,40, 90,50, c2,50):
        randColor(110,50, 40,50, 0,10);
    }
    ctx.strokeStyle = 'rgba('+b.color[1]+',0.6)';
    ctx.beginPath();
    ctx.moveTo( z*b.x+vCX, z*b.y+vCY );
    ctx.lineTo( z*b.vx*-10+z*b.x+vCX, z*b.vy*-10+z*b.y+vCY );
    ctx.closePath();
    ctx.stroke();
    ctx.beginPath();
    ctx.strokeStyle = 'rgb('+b.color[0]+')';
    ctx.fillStyle = 'rgb('+b.color[1]+')';
    ctx.arc( z*b.x+vCX, z*b.y+vCY, z*b.r, 0,7 );
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    /*
    ctx.beginPath(); // debug
    ctx.strokeStyle = '#FFF'; // debug
    ctx.moveTo( z*b.x+vCX, z*b.y+vCY ); // debug
    ctx.lineTo( z*b.vx*10+z*b.x+vCX, z*b.vy*10+z*b.y+vCY ); // debug
    ctx.stroke(); // debug
    */
  }
  //});

  // Draw explosions
  explosions.forEach(function(e) {
    e.t = e.t ? e.t+1 : .5;
    ctx.fillStyle = 'rgba(255,255,255,'+(20-e.t)/20+')';
    ctx.beginPath();
    ctx.arc( z*e.x+vCX, z*e.y+vCY, z*(e.r+e.t*(e.inc||1)), 0,7 );
    ctx.fill();
    if (e.t>19) { // explosion end
      var newList = [];
      explosions.forEach(function(e2){
        if( e2 != e ) newList.push(e2);
      });
      explosions = newList;
    }
  });

  // Draw Ship
  if (shipAlive) {
    ctxMap.fillStyle = '#6BF';
    ctxMap.beginPath();
    ctxMap.arc( mapZ*ship.x+map.cx, mapZ*ship.y+map.cy, 0.9, 0,7 );
    ctxMap.closePath();
    ctxMap.fill();
    ctxMap.strokeStyle = 'rgba(0,200,200,0.5)';
    ctxMap.arc( mapZ*ship.x+map.cx, mapZ*ship.y+map.cy, 10,
                ship.rotate, ship.rotate+turn3 );
    ctxMap.closePath();
    ctxMap.arc( mapZ*ship.x+map.cx, mapZ*ship.y+map.cy, 10,
                ship.rotate+turn3, ship.rotate+turn3*2 );
    ctxMap.closePath();
    ctxMap.arc( mapZ*ship.x+map.cx, mapZ*ship.y+map.cy, 10,
                ship.rotate+turn3*2, ship.rotate+turn3*3 );
    ctxMap.closePath();
    ctxMap.stroke();
    ctx.save();
    ctx.translate( z*ship.x+vCX, z*ship.y+vCY );
    ctx.rotate(ship.rotate);
    var scale = z<1 ? (z+1)/2 : z;
    ctx.scale(scale,scale);
    /*
    ctx.strokeStyle = 'rgba(255,255,255,0.2)'; // debug
    ctx.beginPath(); // debug
    ctx.arc( 0, 0, 20, 0,7 ); // debug
    ctx.stroke(); // debug
    */
    if (usrInput.btU) { // Back Fire
      grd = ctx.createRadialGradient(-9+rand(1),0, 1, -11,0, 4);
      grd.addColorStop(0, '#FF0');
      grd.addColorStop(1, '#F00');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.moveTo(-7.5,0);
      ctx.bezierCurveTo( -11,-7.5, -13,-.5, -20+rand(2),0 );
      ctx.bezierCurveTo( -13,1,  -11,7.5, -7.5,0 );
      ctx.fill();
    }
    if (usrInput.btR) { // Fire Clockwise
      grd = ctx.createRadialGradient(7.5,-5, 0, 7.5,-6, 2);
      grd.addColorStop(0, '#FF0');
      grd.addColorStop(1, '#F00');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.moveTo(7.5,-4);
      ctx.bezierCurveTo( 10,-6.5, 8,-6.5, 7.5,-11+rand(2) );
      ctx.bezierCurveTo( 7,-6.5,  5,-6.5, 7.5,-4 );
      ctx.fill();
    }
    if (usrInput.btL) { // Fire Anti-Clockwise
      grd = ctx.createRadialGradient(7.5,5, 0, 7.5,6, 2);
      grd.addColorStop(0, '#FF0');
      grd.addColorStop(1, '#F00');
      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.moveTo(7.5,4);
      ctx.bezierCurveTo( 10,6.5, 8,6.5, 7.5,11+rand(2) );
      ctx.bezierCurveTo( 7,6.5,  5,6.5, 7.5,4 );
      ctx.fill();
    }
    // Wings
    ctx.fillStyle = '#599';
    ctx.beginPath();
    ctx.moveTo(-2.5,-9.5);
    ctx.bezierCurveTo( 7.5,-12.5, 7.5,12.5, -2.5,9.5 );
    ctx.closePath();
    ctx.fill();
    // Body
    grd = ctx.createRadialGradient(1, 0, 0, 1, 0, 10);
    grd.addColorStop(0, '#F0F8F8');
    grd.addColorStop(1, '#799');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.moveTo(-9,-4.5);
    ctx.bezierCurveTo( 0,-10, 9.5,-4, 10,0 );
    ctx.bezierCurveTo( 10,4,  0,10, -9,4.5 );
    ctx.lineTo(-8, 0);
    ctx.fill();
    // Staff Boids
    ctx.lineWidth = 1/(z+1/2);
    ctx.strokeStyle = '#181';
    var drawTripulation = function(pos) {
      var t = ship.tripulation;
      ctx.beginPath();
      ctx.fillStyle = t[pos] ? 'rgb('+t[pos].color[1]+')' : '#888';
      ctx.arc( -4+(pos*4),0, 2, 0,7 );
      ctx.closePath();
      ctx.fill(); ctx.stroke();
    }
    drawTripulation(0);
    drawTripulation(1);
    drawTripulation(2);
    /*var t = ship.tripulation;
    ctx.beginPath(); ctx.fillStyle = t[0] ? 'rgb('+t[0].color[1]+')' : '#888';
    ctx.arc( -4,0, 2, 0,7 ); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.fillStyle = t[1] ? t[1].color[1] : '#888';
    ctx.arc(  0,0, 2, 0,7 ); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.fillStyle = t[2] ? t[2].color[1] : '#888';
    ctx.arc(  4,0, 2, 0,7 ); ctx.closePath(); ctx.fill(); ctx.stroke();*/
    ctx.restore();
  }

}, 1000/framesPerSec);

d.onclick = function (ev) {
  if (d.mozFullScreenEnabled) b.mozRequestFullScreen();
  if (d.webkitFullscreenEnabled) b.webkitRequestFullScreen();
};

var pressBt = function(bt, on) {
  shipLastJet = now();
  usrInput[bt] = on;
  window[bt].className = on ? 'pressed' : ''
};

d.onkeydown = function (ev) {
  switch (ev.keyCode) {
    case 38: pressBt('btU', true); break;
    case 37: pressBt('btL', true); break;
    case 39: pressBt('btR', true); break;
  }
};

d.onkeyup = function (ev) {
  switch (ev.keyCode) {
    case 38: pressBt('btU', false); break;
    case 37: pressBt('btL', false); break;
    case 39: pressBt('btR', false); break;
  }
};

btL.addEventListener("touchstart", function(){ pressBt('btL', true) });
btR.addEventListener("touchstart", function(){ pressBt('btR', true) });
btU.addEventListener("touchstart", function(){ pressBt('btU', true) });
btL.addEventListener("touchend", function(){ pressBt('btL', false) });
btR.addEventListener("touchend", function(){ pressBt('btR', false) });
btU.addEventListener("touchend", function(){ pressBt('btU', false) });

} catch (e) {
  alert(e)
  throw e;
}
